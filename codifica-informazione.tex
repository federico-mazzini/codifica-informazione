\documentclass[a4paper,12pt]{article}

% Lingua e codifica
\usepackage[italian]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{graphicx}

% Impaginazione e matematica
\usepackage{geometry}
\geometry{margin=2.5cm}
\usepackage{amsmath, amssymb}
\usepackage{booktabs}
\usepackage{array}
\usepackage{hyperref}

% Comandi utili
\newcommand{\code}[1]{\texttt{#1}}



\begin{document}
% ==================================================
% COPERTINA DISPENSA – VERSIONE AVANZATA
% ==================================================
\begin{titlepage}
\centering

{\Large I.I.S. \textit{``Francesco Alberghetti''} Imola}\\[0.3cm]
{\normalsize Liceo Scientifico Scienze Applicate}\\[2.2cm]

\rule{0.85\textwidth}{0.8pt}\\[0.9cm]

{\huge\bfseries Codifica dell'informazione}\\[0.4cm]
{\Large Il sistema binario, esadecimale e cenni di logica booleana}\\[0.6cm]

\rule{0.85\textwidth}{0.8pt}\\[2.5cm]

{\Large Materiale didattico di Informatica}\\[0.3cm]


% ICONA OPZIONALE (consigliata)
% \includegraphics[width=0.3\textwidth]{images/cover_icon.png}

\vfill

{\large Prof. Federico Mazzini}\\[0.3cm]
{\large Anno scolastico 2025 -- 2026}

\end{titlepage}
\newpage
\tableofcontents
\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Informazione, dato e rappresentazione}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Nel contesto dell'informatica tutto ruota intorno a tre concetti fondamentali:
\begin{itemize}
  \item \textbf{dato}
  \item \textbf{informazione}
  \item \textbf{rappresentazione}
\end{itemize}

Questi termini vengono spesso usati in modo intuitivo. Risulta quindi utile fissare una distinzione chiara.

\subsection{Dato}

Per \textbf{dato} si intende un elemento grezzo, non ancora interpretato. Un numero scritto su un foglio, una sequenza di simboli, una misura in forma numerica costituiscono dati.

Un esempio:
\begin{itemize}
  \item La scritta \code{42} rappresenta un dato. Da sola, non indica se si parla di una temperatura, di un'età, di un punteggio o di un codice.
\end{itemize}

\subsection{Informazione}

L'\textbf{informazione} nasce quando un dato viene interpretato in un contesto.

Esempi:
\begin{itemize}
  \item \code{42} accompagnato dalla parola ``anni'' viene interpretato come un'età.
  \item \code{42 °C} indica una temperatura.
  \item \code{42 km} rappresenta una distanza.
\end{itemize}

Il significato dipende quindi dal \textbf{contesto} e dalle \textbf{regole di interpretazione} condivise.

\subsection{Rappresentazione}

La \textbf{rappresentazione} riguarda il modo in cui un'informazione viene codificata. La stessa informazione può avere rappresentazioni differenti. Ad esempio, il numero quarantadue può essere rappresentato come \code{42} in decimale, 42 sassolini su un piano, \code{101010} in binario.

In un computer qualsiasi cosa (numeri, testo, audio, video) viene sempre e solo rappresentata tramite una sequenza di bit (0 e 1). Questo costituisce il punto di partenza per tutto il resto.

\subsection{Perché serve una rappresentazione digitale (e binaria)}

I dispositivi elettronici lavorano con segnali elettrici. Per rendere la lettura di questi segnali più semplice e ridurre gli errori, è utile distinguere soltanto se il segnale è "spento" oppure "acceso".

Per questo, nella progettazione dei calcolatori, si scelgono solo due stati possibili:
\begin{itemize}
  \item stato spento \textrightarrow{} lo rappresentiamo con 0;
  \item stato acceso \textrightarrow{} lo rappresentiamo con 1.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Bit, byte e quantità di informazione}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Il bit}

Il \textbf{bit} (\emph{binary digit}) costituisce l'unità minima di informazione trattata da un calcolatore. Può assumere solo due valori possibili:
\begin{center}
0 oppure 1
\end{center}

\subsection{Il byte e i suoi multipli}

Per ragioni pratiche i bit vengono raggruppati in blocchi di 8. Otto bit formano un \textbf{byte}. Il byte rappresenta l'unità di misura di base per la memoria e per la capacità di memorizzazione.



Multipli più comuni:
\begin{itemize}
  \item 1 KB (kilobyte) = 1024 byte
  \item 1 MB (megabyte) = 1024 KB
  \item 1 GB (gigabyte) = 1024 MB
  \item 1 TB (terabyte) = 1024 GB
  \item 1 PB (petabyte) = 1024 TB
\end{itemize}

\subsubsection*{Perchè proprio 1024?}
L'uso di 1024 anziché 1000 è dovuto alla natura binaria dei calcolatori: 1024= $2^{10}$.

\subsubsection*{Alcuni numeri}

\begin{center}
\begin{tabular}{>{\raggedright\arraybackslash}p{10cm}r}
\toprule
Esempio & Dimensione indicativa \\
\midrule
Breve messaggio WhatsApp (solo testo) & $\sim 1$--$2$ KB \\
Canzone in formato MP3 & $\sim 3$--$10$ MB \\
Foto scattata con uno smartphone & $\sim 3$--$8$ MB \\
La stessa foto caricata su Instagram & $\sim 200$--$800$ KB \\
Foto ad altissima risoluzione & $\sim 50$--$100$ MB \\
DNA di una persona (genoma umano completo, come sequenza di basi) & $\sim 1$--$2$ GB \\
Videogioco moderno (FIFA, COD, GTA) & $\sim 100$ GB \\
Tutte le canzoni su Spotify (stima) & $\sim 500$--$1500$ TB \\
Dati prodotti dagli esperimenti del CERN in un anno & $\sim 10$ PB \\
\bottomrule
\end{tabular}
\end{center}



\subsection{Numero di stati rappresentabili}

Con $n$ bit è possibile rappresentare $2^n$ configurazioni diverse. Ogni bit può assumere 2 valori, quindi le combinazioni totali si ottengono moltiplicando:
\[
2 \cdot 2 \cdot 2 \cdots 2 = 2^n
\]

In maniera molto intuitiva:
\begin{itemize}
  \item con 1 bit → 2 stati (0,1)
  \item con 2 bit → 4 stati (00,01,10,11)
  \item con 3 bit → 8 stati
  \item con 8 bit → 256 stati
  \item con 16 bit → 65536 stati
\end{itemize}

Questa formula è alla base di tutte le scelte di codifica: numero di colori rappresentabili, caratteri possibili, livelli di intensità sonora, ecc.

\subsection{Quantità di informazione e scelta del numero di bit}

Maggiore è il numero di stati da distinguere, maggiore deve essere il numero di bit utilizzati. Ad esempio:
\begin{itemize}
  \item per rappresentare i numeri da 0 a 9 non basta usare 3 bit (8 stati), sono necessari almeno 4 bit (16 stati), anche se alcuni rimangono inutilizzati.
  \item per rappresentare tutti i caratteri di base di una tastiera vengono usati 7 o 8 bit.
  \item per rappresentare un colore in formato RGB a 24 bit vengono sfruttati 8 bit per ciascuno dei tre canali (rosso, verde, blu).
\end{itemize}

\subsubsection*{Perché proprio 1 byte = 8 bit?}
Nei primi calcolatori (dal 1950) non esisteva una dimensione ``giusta'' per il gruppo di bit: furono sperimentate soluzioni con 6, 7, 9 bit e oltre. Il blocco da 8 bit si è però imposto nel tempo come standard perché rappresenta un buon compromesso tra semplicità hardware e capacità informativa.

Con 8 bit si hanno infatti $2^8 = 256$ combinazioni possibili. Questo numero di stati è sufficiente a rappresentare:
\begin{itemize}
  \item le lettere maiuscole e minuscole dell'alfabeto inglese;
  \item le cifre da 0 a 9;
  \item la punteggiatura e vari simboli speciali;
  \item alcuni codici di controllo (ad esempio invio, lo spazio, ecc.).
\end{itemize}
Inoltre, 8 è una potenza di 2 ($2^3 = 8$).

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{I sistemi di numerazione posizionale}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Per comprendere il sistema binario risulta utile definire il funzionamento del sistema decimale.

\subsection{Sistema decimale}

Il sistema decimale si basa sulla \textbf{base 10}. Ciò significa che:
\begin{itemize}
  \item sono disponibili 10 \textbf{simboli}: da 0 a 9;
  \item ogni \textbf{posizione} rappresenta una \textbf{potenza} di 10.
\end{itemize}
Esempio:
\[
472 = 400 + 70 + 2 = 4 \cdot 10^2 + 7 \cdot 10^1 + 2 \cdot 10^0
\]
Il valore di una cifra dipende quindi sia dal simbolo, sia dalla posizione.

\subsection{Definizione di sistema posizionale}

Un sistema di numerazione posizionale è caratterizzato da:
\begin{itemize}
  \item una base $b$ (numero di simboli disponibili);
  \item un insieme di cifre da 0 a $b-1$;
  \item il valore di ciascuna cifra è dato dalla cifra stessa moltiplicata per una potenza della base.
\end{itemize}
Un numero generico in base $b$ può essere scritto come:
\[
(a_n a_{n-1} \dots a_1 a_0)_b
\]
e interpretato come:
\[
 a_n b^n + a_{n-1} b^{n-1} + \dots + a_1 b^1 + a_0 b^0
\]

\subsection{Sistema binario}

Il sistema binario utilizza base 2. Le cifre possibili sono solo due:
\begin{center}
0 e 1
\end{center}

Ogni posizione rappresenta una potenza di 2:
\[
\dots, 2^4, 2^3, 2^2, 2^1, 2^0
\]
Esempio di interpretazione:
\[
(1011)_2 = 1 \cdot 2^3 + 0 \cdot 2^2 + 1 \cdot 2^1 + 1 \cdot 2^0 = 8 + 0 + 2 + 1 = 11_{10}
\]

\subsection{Perché il binario è usato nei calcolatori}

La scelta della base 2 non è casuale. Due stati logici distinti si prestano a essere rappresentati con facilità mediante livelli di tensione differenti (ad esempio, alto/basso, presenza di corrente elettrica oppure no). La semplicità a livello fisico si traduce in affidabilità e velocità.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conversioni tra decimale e binario}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Conversione da binario a decimale}

La conversione da binario a decimale segue direttamente la definizione di sistema posizionale.

Procedura:
\begin{enumerate}
  \item si scrive il numero binario separando le cifre;
  \item si associa a ogni cifra la potenza di 2 corrispondente (partendo da destra con $2^0$);
  \item si moltiplica ogni cifra (0 o 1) per la propria potenza di 2;
  \item si sommano i risultati.
\end{enumerate}

Esempio:
\[
\begin{aligned}
(11010)_2 &= 1 \cdot 2^4 + 1 \cdot 2^3 + 0 \cdot 2^2 + 1 \cdot 2^1 + 0 \cdot 2^0 \\
          &= 16 + 8 + 0 + 2 + 0 = 26_{10}
\end{aligned}
\]

\subsection{Conversione da decimale a binario: metodo delle divisioni successive}

Il metodo più comune per la conversione da decimale a binario si basa su divisioni successive per 2.

Procedura generale:
\begin{enumerate}
  \item si divide il numero decimale per 2;
  \item si registra il resto (0 o 1);
  \item si sostituisce il numero con il quoziente della divisione;
  \item si ripete fino a ottenere quoziente 0;
  \item si leggono i resti dal basso verso l'alto.
\end{enumerate}
Esempio: conversione di 19 in binario.
\[
\begin{aligned}
19 : 2 &= 9 \quad \text{e resto } 1 \\
9 : 2  &= 4 \quad \text{e resto } 1 \\
4 : 2  &= 2 \quad \text{e resto } 0 \\
2 : 2  &= 1 \quad \text{e resto } 0 \\
1 : 2  &= 0 \quad \text{e resto } 1
\end{aligned}
\]

Lettura dei resti dal basso verso l'alto:
\[
19_{10} = (10011)_2
\]

\subsection{Osservazioni sulle conversioni}

Le procedure di conversione non rappresentano solo un esercizio di calcolo: consentono di comprendere come il calcolatore interpreti i numeri e mostrano il legame stretto tra rappresentazione binaria e struttura interna della macchina.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Il sistema esadecimale}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Definizione}

Il sistema esadecimale utilizza base 16. Ciò significa che vengono impiegati 16 simboli distinti:
\begin{itemize}
  \item le cifre decimali da 0 a 9;
  \item le lettere maiuscole da A a F.
\end{itemize}

Le lettere rappresentano i valori decimali da 10 a 15, come mostrato in tabella:

\begin{center}
\begin{tabular}{cc}
\toprule
Simbolo & Valore decimale \\
\midrule
A & 10 \\
B & 11 \\
C & 12 \\
D & 13 \\
E & 14 \\
F & 15 \\
\bottomrule
\end{tabular}
\end{center}

Un numero esadecimale viene talvolta scritto con un prefisso (ad esempio \code{0x2A}) per distinguerlo da un numero decimale.

\subsection{Collegamento con il binario}

La base 16 risulta particolarmente comoda in ambito informatico per il legame diretto con la base 2:
\[
2^4 = 16
\]

Questa uguaglianza implica che \textbf{ogni gruppo di 4 bit} può essere rappresentato con una \textbf{singola cifra esadecimale} e viceversa.

Tabella di corrispondenza tra tutti i blocchi possibili di 4 bit e le cifre esadecimali:

\begin{center}
\begin{tabular}{cc}
\toprule
Binario & Esadecimale \\
\midrule
0000 & 0 \\
0001 & 1 \\
0010 & 2 \\
0011 & 3 \\
0100 & 4 \\
0101 & 5 \\
0110 & 6 \\
0111 & 7 \\
1000 & 8 \\
1001 & 9 \\
1010 & A \\
1011 & B \\
1100 & C \\
1101 & D \\
1110 & E \\
1111 & F \\
\bottomrule
\end{tabular}
\end{center}

Questa corrispondenza rende l'esadecimale una sorta di ``abbreviazione leggibile'' del binario.

\subsection{Conversione binario -- esadecimale}

Grazie alla corrispondenza per gruppi di 4 bit, la conversione risulta diretta e meccanica.

\subsubsection*{Da binario a esadecimale}

Procedura generale:
\begin{enumerate}
  \item si parte dal numero binario;
  \item si raggruppano i bit in blocchi da 4 a partire da destra (se necessario si aggiungono zeri a sinistra nell'ultimo blocco);
  \item per ciascun blocco di 4 bit si individua la cifra esadecimale corrispondente nella tabella;
  \item si scrivono le cifre esadecimali nello stesso ordine.
\end{enumerate}

\paragraph{Esempio 1}

Conversione di \((10110110)_2\) in esadecimale.

\[
10110110_2
\]

Raggruppamento in blocchi da 4 bit partendo da destra:
\[
1011 \quad 0110
\]

Da tabella:
\[
1011_2 = B_{16}, \quad 0110_2 = 6_{16}
\]

Quindi:
\[
(10110110)_2 = (B6)_{16}
\]

\paragraph{Esempio 2}

Conversione di \((1100101)_2\) in esadecimale.

Il numero possiede 7 bit, non un multiplo di 4. Si completa il blocco più a sinistra aggiungendo uno zero:
\[
(1100101)_2 = (0110\ 0101)_2
\]

Blocchi da 4 bit:
\[
0110 \quad 0101
\]

Da tabella:
\[
0110_2 = 6_{16}, \quad 0101_2 = 5_{16}
\]

Quindi:
\[
(1100101)_2 = (65)_{16}
\]

\subsubsection*{Da esadecimale a binario}

Procedura generale:
\begin{enumerate}
  \item si considera ciascuna cifra esadecimale;
  \item per ogni cifra si sostituisce il corrispondente blocco di 4 bit;
  \item si concatenano i blocchi ottenuti.
\end{enumerate}

\paragraph{Esempio 3}

Conversione di \((3F)_{16}\) in binario.

\begin{itemize}
  \item \(3_{16} \rightarrow 0011_2\)
  \item \(F_{16} \rightarrow 1111_2\)
\end{itemize}

Quindi:
\[
(3F)_{16} = (0011\ 1111)_2 = (00111111)_2
\]

\paragraph{Esempio 4}

Conversione di \((A2)_{16}\) in binario.

\begin{itemize}
  \item \(A_{16} \rightarrow 1010_2\)
  \item \(2_{16} \rightarrow 0010_2\)
\end{itemize}

Quindi:
\[
(A2)_{16} = (1010\ 0010)_2 = (10100010)_2
\]

\subsection{Perché usare l'esadecimale}

La scrittura binaria di numeri lunghi risulta poco leggibile e difficile da controllare a colpo d'occhio. L'esadecimale offre:

\begin{itemize}
  \item una \textbf{forma più compatta}: riduce la lunghezza delle sequenze rispetto al binario;
  \item una \textbf{relazione diretta con il binario}: la conversione avviene per gruppi di 4 bit, senza calcoli complessi;
  \item una \textbf{maggiore leggibilità} per esseri umani in contesti tecnici (programmazione di basso livello, analisi della memoria, debug).
\end{itemize}

In molti strumenti di sviluppo, valori che la macchina tratta in binario vengono presentati in esadecimale perché risulta un compromesso efficace tra ``vicinanza all'hardware'' e comprensione umana.
\subsection{Perché si usa l'esadecimale}

Le sequenze di bit risultano poco leggibili quando diventano lunghe. L'esadecimale permette di riscrivere gruppi di bit in una forma più compatta e comprensibile, mantenendo comunque una corrispondenza esatta con il binario.

In pratica, i bit vengono raggruppati a gruppi di 4 e ogni gruppo viene sostituito con una cifra esadecimale. In questo modo una lunga sequenza di 0 e 1 si trasforma in pochi simboli più facili da interpretare.

\paragraph{Esempio}

Si consideri il numero binario:
\[
(101010)_2
\]

Poiché il numero contiene 6 bit, si aggiungono zeri a sinistra fino a ottenere un multiplo di 4:
\[
(101010)_2 = (0010\ 1010)_2
\]

Si convertono i blocchi separatamente:
\[
0010_2 = 2_{16}, \quad 1010_2 = A_{16}
\]

Si ottiene quindi:
\[
(101010)_2 = (2A)_{16}
\]

Questo esempio mostra come una sequenza binaria venga trasformata in una forma più compatta e leggibile. L'esadecimale consente quindi di ``tradurre'' il linguaggio dei bit in una notazione più adatta alla lettura umana, pur rimanendo rigorosamente legata alla rappresentazione interna del calcolatore.
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Logica booleana}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Decisioni sì/no}

Nella vita quotidiana le decisioni spesso dipendono da condizioni che possono essere considerate vere o false.

Esempi:
\begin{itemize}
  \item ``se piove, allora si usa l'ombrello'';
  \item ``se l'età è maggiore o uguale a 18, allora è consentito votare'';
  \item ``se la batteria è scarica, allora si ricarica il dispositivo''.
\end{itemize}

Ogni affermazione del tipo ``condizione → azione'' può essere formalizzata con la logica booleana.

\subsection{Variabile booleana}

Una \textbf{variabile booleana} può assumere solo due valori:
\begin{itemize}
  \item vero (spesso indicato con 1);
  \item falso (spesso indicato con 0).
\end{itemize}

Questo modello è perfettamente compatibile con la rappresentazione mediante bit.

\subsection{Operatori logici fondamentali}

Gli operatori logici di base sono:
\begin{description}
  \item[NOT] (negazione): inverte il valore di verità.
  \item[AND] (congiunzione): è vero solo se entrambe le condizioni sono vere.
  \item[OR] (disgiunzione inclusiva): è vero se almeno una delle condizioni è vera.
\end{description}

\subsection{Tabelle di verità}
Le tabelle di verità descrivono il comportamento di un operatore logico rispetto a tutti i possibili input.

\bigskip

\noindent\textbf{Operatore NOT (negazione)}

L'operatore NOT inverte il valore logico della variabile: il vero diventa falso e il falso diventa vero.

\[
\begin{array}{c|c}
A & \text{NOT } A \\
\hline
0 & 1 \\
1 & 0
\end{array}
\]

\bigskip

\noindent\textbf{Operatore AND (congiunzione)}

L'operatore AND restituisce vero solo quando entrambe le variabili assumono valore vero.

\[
\begin{array}{c|c|c}
A & B & A \land B \\
\hline
0 & 0 & 0 \\
0 & 1 & 0 \\
1 & 0 & 0 \\
1 & 1 & 1
\end{array}
\]

\bigskip

\noindent\textbf{Operatore OR (disgiunzione)}

L'operatore OR restituisce vero quando almeno una delle due variabili è vera.

\[
\begin{array}{c|c|c}
A & B & A \lor B \\
\hline
0 & 0 & 0 \\
0 & 1 & 1 \\
1 & 0 & 1 \\
1 & 1 & 1
\end{array}
\]

\subsection{Proprietà degli operatori logici}

Gli operatori AND e OR possiedono diverse proprietà utili nella semplificazione delle espressioni booleane.

\paragraph{Proprietà commutativa}

Per AND e OR vale:
\[
A \land B = B \land A \\
A \lor B = B \lor A
\]

\paragraph{Proprietà associativa}

L'ordine di raggruppamento non modifica il risultato:
\[
(A \land B) \land C = A \land (B \land C) \\
(A \lor B) \lor C = A \lor (B \lor C)
\]

\paragraph{Proprietà distributiva}

AND e OR si distribuiscono in modo analogo a moltiplicazione e somma:
\[
A \land (B \lor C) = (A \land B) \lor (A \land C) \\
A \lor (B \land C) = (A \lor B) \land (A \lor C)
\]

\subsection{Leggi di De Morgan}

Le leggi di De Morgan permettono di trasformare la negazione di una congiunzione in una disgiunzione di negazioni e viceversa:
\[
\neg(A \land B) = (\neg A) \lor (\neg B) \\
\neg(A \lor B) = (\neg A) \land (\neg B)
\]

Queste trasformazioni risultano fondamentali nella progettazione di circuiti logici e nella semplificazione di condizioni nei programmi.

\subsection{Espressioni booleane}

Un'espressione booleana combina variabili booleane e operatori logici.

Esempio:
\[
(A \land B) \lor (\neg C)
\]

Un'espressione di questo tipo può rappresentare una regola decisionale, una condizione di controllo o il comportamento di un circuito.

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Codifica dei caratteri}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Dal simbolo al numero}

Per memorizzare e trasmettere testo, ogni carattere deve essere associato a un codice numerico. Questo codice viene poi rappresentato in binario e memorizzato come sequenza di bit.

\subsubsection*{L'importanza di standard comuni}

Le codifiche caratteri permettono di trasformare un dato in informazione e risultano così importanti perché vengono utilizzate e condivise in tutto il mondo. Se ogni produttore di computer o ogni programma usasse una codifica ``personale'' e diversa dalle altre, lo stesso testo sarebbe diverso da computer a computer, o da nazione a nazione. L'informatica, essendo una disciplina globale, basa tutto il suo mondo sull'utilizzo di standard comuni.\\\\
Grazie a standard comuni:
\begin{itemize}
  \item un file di testo scritto su un computer può essere letto correttamente su un altro;
  \item messaggi, email e pagine web mantengono gli stessi caratteri, accenti e simboli indipendentemente dal dispositivo;
  \item è possibile scambiare informazioni tra sistemi diversi senza dover riconvertire continuamente la rappresentazione dei caratteri.
\end{itemize}
La presenza di standard condivisi rende quindi possibile la comunicazione digitale su scala globale.

\subsection{Codifica ASCII}

La codifica \textbf{ASCII} (American Standard Code for Information Interchange) è una delle prime standardizzazioni per la rappresentazione dei caratteri. Il suo scopo è associare in modo univoco ad ogni carattere un numero intero.

Caratteristiche principali:
\begin{itemize}
  \item utilizzo di 7 bit per carattere (128 possibili simboli, da 0 a 127);
  \item presenza di lettere maiuscole e minuscole dell'alfabeto inglese;
  \item cifre da 0 a 9;
  \item segni di punteggiatura;
  \item alcuni caratteri di controllo (invio, tabulazione, ecc.).
\end{itemize}

Il calcolatore non memorizza direttamente le lettere, ma memorizza i \textbf{codici numerici} corrispondenti. La tastiera invia il codice del tasto premuto e il programma visualizza il carattere associato al codice.

Esempi di associazione tra caratteri e codici ASCII:

\begin{center}
\begin{tabular}{ccc}
\toprule
Carattere & Codice decimale & Codice binario (8 bit) \\
\midrule
\code{'0'} & 48 & 00110000 \\
\code{'1'} & 49 & 00110001 \\
\code{'A'} & 65 & 01000001 \\
\code{'B'} & 66 & 01000010 \\
\code{'a'} & 97 & 01100001 \\
spazio & 32 & 00100000 \\
\bottomrule
\end{tabular}
\end{center}


ASCII è stato progettato per l'inglese. Non include le lettere accentate, caratteri di alfabeti non latini, simboli di lingue asiatiche o emoji. Con la diffusione globale dei calcolatori è diventato necessario utilizzare sistemi che permettessero di rappresentare molti più simboli. Oggi, quindi, la codifica ASCII non è più molto utilizzata. Altrimenti non potremmo rappresentare le emoji, limitandoci ad esempio a questo :D


\begin{center}
\includegraphics[width=1\textwidth]{images/ascii-table.jpg}

\emph{Tabella ASCII completa}
\end{center}


\subsubsection*{Esempio completo: da testo a numeri}

Si consideri la frase:
\begin{center}
\code{"ciao a tutti"}
\end{center}

\begin{center}
\begin{tabular}{cc}
\toprule
Carattere & Codice decimale ASCII \\
\midrule
\code{'c'} & 99 \\
\code{'i'} & 105 \\
\code{'a'} & 97 \\
\code{'o'} & 111 \\
spazio     & 32 \\
\code{'a'} & 97 \\
spazio     & 32 \\
\code{'t'} & 116 \\
\code{'u'} & 117 \\
\code{'t'} & 116 \\
\code{'t'} & 116 \\
\code{'i'} & 105 \\
\bottomrule
\end{tabular}
\end{center}
Seguendo la tabella ASCII, la frase \code{"ciao a tutti"} viene memorizzata come una sequenza di numeri:
\[
\text{``ciao a tutti''} \rightarrow 99\;105\;97\;111\;32\;97\;32\;116\;117\;116\;116\;105
\]
In codice binario, quindi sul nostro computer, la frase è rappresentata in questa maniera:
\[
\begin{aligned}
\text{``ciao a tutti''} \rightarrow\ &01100011\;01101001\;01100001\;01101111\;00100000\;01100001\\
                                     &00100000\;01110100\;01110101\;01110100\;01110100\;01101001
\end{aligned}
\]

\subsubsection*{L'astrazione che ritorna}
Quello che al nostro occhio appare come una sequenza di lettere e spazi, per il calcolatore è solamente una sequenza di segnali elettrici (0 e 1). Anche in questo caso possiamo parlare di \textbf{astrazione}. Nascondiamo i segnali elettrici, nascondiamo i bit e i numeri della tabella ASCII, rimane il livello umano, quello (per noi) semplice da capire e veramente utile.



\subsection{Unicode}

La codifica \textbf{Unicode} nasce per risolvere un problema semplice: i computer non vengono usati solo da persone che scrivono in inglese. La codifica ASCII, metteva a disposizione 128 possibili caratteri, ma ad oggi, tra lettere accentate, alfabeti diversi (greco, cirillico, arabo, ecc.), simboli matematici, frecce, segni grafici ed emoji, i caratteri da rappresentare sono migliaia.


L'idea di base di Unicode è simile a quella di ASCII: \textbf{ogni simbolo che può comparire su uno schermo o in un testo digitale riceve un numero}. La vera differenza sta nel \emph{quantitativo} di simboli che si possono rappresentare.
Nel codice ASCII classico, usando 7 bit, si hanno a disposizione 
\[
2^7 = 128 \text{ simboli diversi},
\] 
Unicode utilizza numeri più grandi, scritti spesso in \textbf{codice esadecimale} per comodità. Con 5 cifre esadecimali si possono rappresentare fino a
\[
16^5 = 1\,048\,576 \text{ simboli diversi},
\]
molto di più dei 128 di ASCII :D. 


\begin{center}
\includegraphics[width=1\textwidth]{images/unicode-emoji.png}

\emph{Tabella parziale Unicode rappresentante alcune emoji}
\end{center}

In sintesi, Unicode definisce un grande ``dizionario'' mondiale dei simboli, molto più ampio di quello offerto da ASCII, in cui a ogni simbolo corrisponde un numero univoco.

Questo dizionario stabilisce \emph{quali} simboli esistono e \emph{quale} numero li rappresenta, ma non specifica ancora \emph{come} questi numeri vengano memorizzati in termini di byte e bit. Per passare dai code point ai bit veri e propri, quindi alla \textbf{rappresentazione pratica} si usano delle regole chiamate \textbf{codifiche}, la più importante è UTF-8.


\subsection{UTF-8}

UTF-8 è una delle possibili \textbf{codifiche} di Unicode. \\\\
Le sue caratteristiche fondamentali sono:
\begin{itemize}
  \item codifica a lunghezza variabile: da 1 a 4 byte per carattere;
  \item compatibilità con ASCII: i primi 128 caratteri (quelli ASCII) vengono rappresentati con un singolo byte identico ad ASCII;
  \item caratteri non ASCII (accenti, simboli, emoji) utilizzano 2, 3 o 4 byte.
\end{itemize}
La lunghezza variabile di UTF-8 può essere illustrata mostrando la reale rappresentazione in bit di alcuni caratteri e parole:

\begin{center}
\begin{tabular}{>{\ttfamily}c l}
\toprule
Simbolo / parola & Rappresentazione in bit (UTF-8) \\
\midrule
'A'      & 01000001 \\
'z'      & 01111010 \\
'è'      & 11000011\ 10101000 \\
'€'      & 11100010\ 10000010\ 10101100 \\
\midrule
"casa"   & 01100011\ 01100001\ 01110011\ 01100001 \\
"città"  & 01100011\ 01101001\ 01110100\ 01110100\ 11000011\ 10100000 \\
\bottomrule
\end{tabular}
\end{center}
Si osserva che:
\begin{itemize}
  \item i caratteri ASCII semplici (come \code{'A'} e \code{'z'}) occupano 1 solo byte;
  \item caratteri accentati come \code{'è'} richiedono più spazio;
  \item simboli come \code{'€'} utilizzano ancora più byte;
  \item due parole apparentemente simili, come \code{"casa"} e \code{"città"}, occupano quantità di memoria diverse a causa delle lettere accentate.
\end{itemize}

% --- INIZIO RISPOSTA: Come fa il computer a sapere quanti byte leggere in UTF-8 ---
\subsubsection*{Come fa il computer a sapere quanti byte leggere?}

Se UTF-8 usa da 1 a 4 byte per carattere, \textbf{come fa il computer a capire quanti byte fanno parte di ciascun carattere}? Non ci sono virgole o spazi tra un carattere e l'altro nel flusso di byte. L'idea è che \textbf{i primi bit del primo byte} di ogni carattere contengono un ``segnale'' che indica quanto è lungo il carattere. 

\subsubsection*{Esempio}

\begin{center}
\begin{tabular}{>{\ttfamily}c l}
\toprule
Simbolo & Rappresentazione in byte \\
\midrule
'A'   & 01000001 \\
'è'   & 11000011\ 10101000 \\
'€'   & 11100010\ 10000010\ 10101100 \\
\bottomrule
\end{tabular}
\end{center}
Si osserva che:
\begin{itemize}
  \item quando il carattere occupa \textbf{un solo byte}, il primo bit è 0 (\code{'A'});
  \item quando il carattere occupa \textbf{2 byte}, i primi 2 bit sono 1 (\code{'è'});
  \item quando il carattere occupa \textbf{3 byte}, i primi 3 bit sono 1 (\code{'è'});
  \item i byte che seguono un carattere più lungo (secondo, terzo o quarto byte) iniziano sempre con 1. Questo bit prende il nome di \textbf{bit di continuazione}, perchè segnala al computer che \textbf{non} si tratta dell'inizio di un nuovo carattere, ma della continuazione del precedente. 
\end{itemize}

In questo modo, leggendo i byte uno dopo l'altro e osservando i primi bit, il computer riesce a capire automaticamente quanti byte deve usare per ricostruire ogni carattere.



\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Codifica delle immagini}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Immagini raster}

Le immagini digitali di uso comune (fotografie, screenshot, immagini mostrate su schermo) sono generalmente rappresentate in formato \textbf{raster}.

Un'immagine raster è composta da una griglia regolare di \textbf{pixel}, ovvero i più piccoli elementi visivi che la costituiscono. Ogni pixel contiene un'informazione relativa al colore.

\begin{center}
\includegraphics[width=0.6\textwidth]{images/raster-graphic.jpg}

\emph{Ingrandimento di un'immagine raster con evidenza della griglia di pixel.}
\end{center}

Quando un'immagine raster viene ingrandita oltre una certa soglia, la struttura a pixel diventa visibile, producendo l'effetto ``sgranato''.

\subsection{Risoluzione}

La \textbf{risoluzione} indica il numero di pixel presenti in orizzontale e verticale. Determina il livello di dettaglio dell'immagine.

Esempi comuni:
\begin{itemize}
  \item 800×600 pixel → bassa definizione
  \item 1920×1080 pixel → Full HD
  \item 3840×2160 pixel → 4K
\end{itemize}

\begin{center}
\includegraphics[width=0.8\textwidth]{images/raster-strawberry.jpeg}

\end{center}

\subsection{Profondità di colore}

La \textbf{profondità di colore} indica quanti bit vengono utilizzati per rappresentare il colore di ciascun pixel. Valori tipici:
\begin{itemize}
  \item 1 bit → solo bianco e nero
  \item 8 bit → 256 livelli di grigio
  \item 24 bit → RGB, oltre 16 milioni di colori
\end{itemize}

Il numero di colori rappresentabili è dato dal valore: $2^n$

\begin{center}
\includegraphics[width=0.55\textwidth]{images/bit-depth-example.png}

\end{center}

\subsection{Immagini vettoriali}

Le \textbf{immagini vettoriali} non sono descritte tramite pixel, ma attraverso formule matematiche che definiscono linee, curve e forme geometriche. Ogni elemento viene rappresentato come oggetto scalabile, il cui aspetto non dipende dalla risoluzione dello schermo.

Grazie a questa caratteristica, l'ingrandimento non comporta perdita di qualità: i contorni rimangono sempre nitidi e privi di sgranature. Questo rende le immagini vettoriali particolarmente adatte per loghi, icone, diagrammi e grafici tecnici.

\begin{center} 
\includegraphics[width=0.5\textwidth]{images/Vector_vs_raster.png}

\emph{Confronto tra immagine raster e vettoriale a forte ingrandimento.}
\end{center}

Un comportamento analogo si osserva in molti file PDF: durante lo zoom, testo e linee restano perfettamente definiti perché descritti mediante elementi vettoriali. Se il PDF contiene invece immagini raster, l’ingrandimento evidenzia la struttura a pixel e produce sgranature visibili.

\end{document}